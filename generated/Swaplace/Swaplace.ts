// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class SwapAccepted extends ethereum.Event {
  get params(): SwapAccepted__Params {
    return new SwapAccepted__Params(this);
  }
}

export class SwapAccepted__Params {
  _event: SwapAccepted;

  constructor(event: SwapAccepted) {
    this._event = event;
  }

  get swapId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get owner(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get allowed(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class SwapCanceled extends ethereum.Event {
  get params(): SwapCanceled__Params {
    return new SwapCanceled__Params(this);
  }
}

export class SwapCanceled__Params {
  _event: SwapCanceled;

  constructor(event: SwapCanceled) {
    this._event = event;
  }

  get swapId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get owner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class SwapCreated extends ethereum.Event {
  get params(): SwapCreated__Params {
    return new SwapCreated__Params(this);
  }
}

export class SwapCreated__Params {
  _event: SwapCreated;

  constructor(event: SwapCreated) {
    this._event = event;
  }

  get swapId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get owner(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get allowed(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class Swaplace__createSwapInputSwapStruct extends ethereum.Tuple {
  get owner(): Address {
    return this[0].toAddress();
  }

  get config(): BigInt {
    return this[1].toBigInt();
  }

  get biding(): Array<Swaplace__createSwapInputSwapBidingStruct> {
    return this[2].toTupleArray<Swaplace__createSwapInputSwapBidingStruct>();
  }

  get asking(): Array<Swaplace__createSwapInputSwapAskingStruct> {
    return this[3].toTupleArray<Swaplace__createSwapInputSwapAskingStruct>();
  }
}

export class Swaplace__createSwapInputSwapBidingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__createSwapInputSwapAskingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__getSwapResultValue0Struct extends ethereum.Tuple {
  get owner(): Address {
    return this[0].toAddress();
  }

  get config(): BigInt {
    return this[1].toBigInt();
  }

  get biding(): Array<Swaplace__getSwapResultValue0BidingStruct> {
    return this[2].toTupleArray<Swaplace__getSwapResultValue0BidingStruct>();
  }

  get asking(): Array<Swaplace__getSwapResultValue0AskingStruct> {
    return this[3].toTupleArray<Swaplace__getSwapResultValue0AskingStruct>();
  }
}

export class Swaplace__getSwapResultValue0BidingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__getSwapResultValue0AskingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__makeAssetResultValue0Struct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__makeSwapResultValue0Struct extends ethereum.Tuple {
  get owner(): Address {
    return this[0].toAddress();
  }

  get config(): BigInt {
    return this[1].toBigInt();
  }

  get biding(): Array<Swaplace__makeSwapResultValue0BidingStruct> {
    return this[2].toTupleArray<Swaplace__makeSwapResultValue0BidingStruct>();
  }

  get asking(): Array<Swaplace__makeSwapResultValue0AskingStruct> {
    return this[3].toTupleArray<Swaplace__makeSwapResultValue0AskingStruct>();
  }
}

export class Swaplace__makeSwapResultValue0BidingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__makeSwapResultValue0AskingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__makeSwapInputBidingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__makeSwapInputAskingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__parseDataResult {
  value0: Address;
  value1: BigInt;

  constructor(value0: Address, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): Address {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class Swaplace extends ethereum.SmartContract {
  static bind(address: Address): Swaplace {
    return new Swaplace("Swaplace", address);
  }

  acceptSwap(swapId: BigInt, receiver: Address): boolean {
    let result = super.call(
      "acceptSwap",
      "acceptSwap(uint256,address):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(swapId),
        ethereum.Value.fromAddress(receiver),
      ],
    );

    return result[0].toBoolean();
  }

  try_acceptSwap(
    swapId: BigInt,
    receiver: Address,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "acceptSwap",
      "acceptSwap(uint256,address):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(swapId),
        ethereum.Value.fromAddress(receiver),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  createSwap(swap: Swaplace__createSwapInputSwapStruct): BigInt {
    let result = super.call(
      "createSwap",
      "createSwap((address,uint256,(address,uint256)[],(address,uint256)[])):(uint256)",
      [ethereum.Value.fromTuple(swap)],
    );

    return result[0].toBigInt();
  }

  try_createSwap(
    swap: Swaplace__createSwapInputSwapStruct,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "createSwap",
      "createSwap((address,uint256,(address,uint256)[],(address,uint256)[])):(uint256)",
      [ethereum.Value.fromTuple(swap)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getSwap(swapId: BigInt): Swaplace__getSwapResultValue0Struct {
    let result = super.call(
      "getSwap",
      "getSwap(uint256):((address,uint256,(address,uint256)[],(address,uint256)[]))",
      [ethereum.Value.fromUnsignedBigInt(swapId)],
    );

    return changetype<Swaplace__getSwapResultValue0Struct>(result[0].toTuple());
  }

  try_getSwap(
    swapId: BigInt,
  ): ethereum.CallResult<Swaplace__getSwapResultValue0Struct> {
    let result = super.tryCall(
      "getSwap",
      "getSwap(uint256):((address,uint256,(address,uint256)[],(address,uint256)[]))",
      [ethereum.Value.fromUnsignedBigInt(swapId)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Swaplace__getSwapResultValue0Struct>(value[0].toTuple()),
    );
  }

  makeAsset(
    addr: Address,
    amountOrId: BigInt,
  ): Swaplace__makeAssetResultValue0Struct {
    let result = super.call(
      "makeAsset",
      "makeAsset(address,uint256):((address,uint256))",
      [
        ethereum.Value.fromAddress(addr),
        ethereum.Value.fromUnsignedBigInt(amountOrId),
      ],
    );

    return changetype<Swaplace__makeAssetResultValue0Struct>(
      result[0].toTuple(),
    );
  }

  try_makeAsset(
    addr: Address,
    amountOrId: BigInt,
  ): ethereum.CallResult<Swaplace__makeAssetResultValue0Struct> {
    let result = super.tryCall(
      "makeAsset",
      "makeAsset(address,uint256):((address,uint256))",
      [
        ethereum.Value.fromAddress(addr),
        ethereum.Value.fromUnsignedBigInt(amountOrId),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Swaplace__makeAssetResultValue0Struct>(value[0].toTuple()),
    );
  }

  makeSwap(
    owner: Address,
    allowed: Address,
    expiry: BigInt,
    biding: Array<Swaplace__makeSwapInputBidingStruct>,
    asking: Array<Swaplace__makeSwapInputAskingStruct>,
  ): Swaplace__makeSwapResultValue0Struct {
    let result = super.call(
      "makeSwap",
      "makeSwap(address,address,uint256,(address,uint256)[],(address,uint256)[]):((address,uint256,(address,uint256)[],(address,uint256)[]))",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromAddress(allowed),
        ethereum.Value.fromUnsignedBigInt(expiry),
        ethereum.Value.fromTupleArray(biding),
        ethereum.Value.fromTupleArray(asking),
      ],
    );

    return changetype<Swaplace__makeSwapResultValue0Struct>(
      result[0].toTuple(),
    );
  }

  try_makeSwap(
    owner: Address,
    allowed: Address,
    expiry: BigInt,
    biding: Array<Swaplace__makeSwapInputBidingStruct>,
    asking: Array<Swaplace__makeSwapInputAskingStruct>,
  ): ethereum.CallResult<Swaplace__makeSwapResultValue0Struct> {
    let result = super.tryCall(
      "makeSwap",
      "makeSwap(address,address,uint256,(address,uint256)[],(address,uint256)[]):((address,uint256,(address,uint256)[],(address,uint256)[]))",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromAddress(allowed),
        ethereum.Value.fromUnsignedBigInt(expiry),
        ethereum.Value.fromTupleArray(biding),
        ethereum.Value.fromTupleArray(asking),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Swaplace__makeSwapResultValue0Struct>(value[0].toTuple()),
    );
  }

  packData(allowed: Address, expiry: BigInt): BigInt {
    let result = super.call("packData", "packData(address,uint256):(uint256)", [
      ethereum.Value.fromAddress(allowed),
      ethereum.Value.fromUnsignedBigInt(expiry),
    ]);

    return result[0].toBigInt();
  }

  try_packData(allowed: Address, expiry: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "packData",
      "packData(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(allowed),
        ethereum.Value.fromUnsignedBigInt(expiry),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  parseData(config: BigInt): Swaplace__parseDataResult {
    let result = super.call(
      "parseData",
      "parseData(uint256):(address,uint256)",
      [ethereum.Value.fromUnsignedBigInt(config)],
    );

    return new Swaplace__parseDataResult(
      result[0].toAddress(),
      result[1].toBigInt(),
    );
  }

  try_parseData(
    config: BigInt,
  ): ethereum.CallResult<Swaplace__parseDataResult> {
    let result = super.tryCall(
      "parseData",
      "parseData(uint256):(address,uint256)",
      [ethereum.Value.fromUnsignedBigInt(config)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Swaplace__parseDataResult(value[0].toAddress(), value[1].toBigInt()),
    );
  }

  supportsInterface(interfaceID: Bytes): boolean {
    let result = super.call(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceID)],
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(interfaceID: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceID)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  totalSwaps(): BigInt {
    let result = super.call("totalSwaps", "totalSwaps():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSwaps(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSwaps", "totalSwaps():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class AcceptSwapCall extends ethereum.Call {
  get inputs(): AcceptSwapCall__Inputs {
    return new AcceptSwapCall__Inputs(this);
  }

  get outputs(): AcceptSwapCall__Outputs {
    return new AcceptSwapCall__Outputs(this);
  }
}

export class AcceptSwapCall__Inputs {
  _call: AcceptSwapCall;

  constructor(call: AcceptSwapCall) {
    this._call = call;
  }

  get swapId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get receiver(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class AcceptSwapCall__Outputs {
  _call: AcceptSwapCall;

  constructor(call: AcceptSwapCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class CancelSwapCall extends ethereum.Call {
  get inputs(): CancelSwapCall__Inputs {
    return new CancelSwapCall__Inputs(this);
  }

  get outputs(): CancelSwapCall__Outputs {
    return new CancelSwapCall__Outputs(this);
  }
}

export class CancelSwapCall__Inputs {
  _call: CancelSwapCall;

  constructor(call: CancelSwapCall) {
    this._call = call;
  }

  get swapId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class CancelSwapCall__Outputs {
  _call: CancelSwapCall;

  constructor(call: CancelSwapCall) {
    this._call = call;
  }
}

export class CreateSwapCall extends ethereum.Call {
  get inputs(): CreateSwapCall__Inputs {
    return new CreateSwapCall__Inputs(this);
  }

  get outputs(): CreateSwapCall__Outputs {
    return new CreateSwapCall__Outputs(this);
  }
}

export class CreateSwapCall__Inputs {
  _call: CreateSwapCall;

  constructor(call: CreateSwapCall) {
    this._call = call;
  }

  get swap(): CreateSwapCallSwapStruct {
    return changetype<CreateSwapCallSwapStruct>(
      this._call.inputValues[0].value.toTuple(),
    );
  }
}

export class CreateSwapCall__Outputs {
  _call: CreateSwapCall;

  constructor(call: CreateSwapCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class CreateSwapCallSwapStruct extends ethereum.Tuple {
  get owner(): Address {
    return this[0].toAddress();
  }

  get config(): BigInt {
    return this[1].toBigInt();
  }

  get biding(): Array<CreateSwapCallSwapBidingStruct> {
    return this[2].toTupleArray<CreateSwapCallSwapBidingStruct>();
  }

  get asking(): Array<CreateSwapCallSwapAskingStruct> {
    return this[3].toTupleArray<CreateSwapCallSwapAskingStruct>();
  }
}

export class CreateSwapCallSwapBidingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class CreateSwapCallSwapAskingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}
